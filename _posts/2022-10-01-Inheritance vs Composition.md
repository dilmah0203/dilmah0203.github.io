---
layout: single
title : 상속(Inheritance)과 조합(Composition)
excerpt : ""
---

상속이란,

- 기존에 정의되어 있는 클래스의 필드와 메소드를 물려받아 새로운 클래스를 생성하는 기법
- 중복코드 제거와 기능확장을 할 수 있다.
- 클래스들의 계층적인 구조를 만들 수 있다.

### 상속의 문제

1. **캡슐화가 깨지고 결합도가 높아진다**

객체지향 프로그래밍에서는 결합도는 낮고 응집도는 높을수록 좋다. 하지만 상속을 이용하면 캡슐화는 깨지고 결합도는 높아진다. 이유는 상속은 상위 클래스와 강하게 의존하기 때문에 상위 클래스의 구현이 바뀌면 이 클래스를 상속받은 하위클래스에도 영향을 미치기 때문이다. 

2. **상위 클래스의 public 메소드가 하위 클래스에도 노출된다**

상속은 부모 클래스와 강하게 의존하기 때문에 부모 클래스의 캡슐화를 해치고 결합도가 높아진다. 부모 클래스의 구현을 변경하면, 많은 자식 클래스를 모두 변경 해줘야 하기 때문이다. 불필요한 메소드도 상속받는 문제도 있다.

![image](https://github.com/dilmah0203/dilmah0203.github.io/blob/master/assets/Stack.png)

이 Stack 클래스는 Vector라는 클래스를 상속받고 있다.

![img2](https://github.com/dilmah0203/TIL/blob/main/Image/StackTest.png) 

문자열을 저장하는 Stack을 선언 후 Stack에서 지원하는 메소드로 문자열을 넣어주었다. Stack에서 문자열을 꺼내면 마지막에 넣은 문자열이 반환될 것이라고 예상할 수 있다. 하지만 실제 실행 결과는 예상과 다르게 두 번째에 넣은 문자열이 반환된다.

![img3](https://github.com/dilmah0203/TIL/blob/main/Image/StackTestFailed.png)

add() 메소드는 Stack의 규칙을 따르지 않기 때문이다. 원래 Stack은 나중에 들어온 원소부터 먼저 반환되어야 하는데 add() 메소드는 순서와 상관없이 특정 인덱스에 원소를 추가할 수 있게 허용하고 있다. Vector를 상속한 Stack은 자신에게 필요하지 않은 메소드를 노출할 수 밖에 없다.

### 조합은 상속의 문제점을 어떻게 해결할까?

조합이란,

- 기존 클래스의 인스턴스를 새로운 클래스의 private 필드로 참조하고 메소드를 호출하는 방식으로 구현한다. 
- public 인터페이스에 의존해서 부분 객체의 내부 구현이 변경되어도 비교적 안전하다.
- 상속과 달리 부분 객체의 내부 구현이 공개되지 않는다.

### 상속과 조합은 언제 써야할까?

**상속의 목적**

1. 서브타이핑 - 다형적인 계층구조 구현(부모와 자식 행동이 호환)
2. 서브클래싱 - 다른 클래스의 코드를 재사용(부모와 자식 행동이 호환 x)

이 두가지의 서로 다른 상속의 차이는 부모 클래스의 행동과 자식 클래스의 행동의 호환여부이다. 두 객체가 서로 Is-A 관계이거나 클라이언트 관점에서 두 객체가 동일한 행동을 할 것이라 기대될 때 상속을 고려한다.

**상속**이 **Is-A** 관계라면 **조합**은 **Has-A** 관계이다. 객체가 변경되더라도 영향을 최소화할 수 있기 때문에 변경에 안정적이며 느슨하게 결합되므로 설계가 유연해진다.




