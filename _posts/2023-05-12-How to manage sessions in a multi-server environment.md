---
layout: single
title : 다중 서버 환경에서 session 불일치 문제와 해결 방법
excerpt : ""
---

## 서버 다중화 환경에서 session 불일치

사용자가 로그인하기 위해 POST 요청을 보내면 서버는 이 요청을 받고 session id를 발급한다. 그리고 session id를 응답 객체에 실어 사용자에게 재전송하고 사용자는 브라우저의
쿠키 저장소에 session id를 저장해 상태를 유지할 수 있다.

![img](/assets/images/session.png)

위 그림처럼 단일 서버 환경에서는 session을 통한 로그인을 구현할 때 session 불일치 문제를 신경쓸 필요가 없다. 
하지만 서비스가 커짐에 따라 한 대의 서버로 운영하는 것이 불가능해질 경우 서버를 업그레이드 해야하는데 다음과 같은 두 가지 방식이 존재한다.

첫 번째 방법은 **scale-up** 방식이다. **서버 자체의 성능을 늘려** 트래픽을 견딜 수 있게 하는 방식이지만, 여전히 서버 한 대에 모든 트래픽이 집중될 가능성이 있으므로 만일 서버 장애가 생길 시 서버가 복구될 때까지 서비스를 중단해야 하는 상황이 발생할 수 있다.

두 번째 방법은 **scale-out** 방식이다. **서버를 여러대로 늘려**서 각 서버에 로드밸런싱으로 트래픽을 분산하게 한다. 그래서 서버 한 대에 장애가 생겨도 다른 서버에 영향을 주지 않는다. 그러나 이 때 데이터 정합성, **세션 불일치 문제**가 발생할 수 있다. 왜냐하면 여러 대의 서버가 각각 세션 저장소를 독립적으로 갖기 때문에 데이터 불일치가 발생하기 때문이다.

![img2](/assets/images/session2.png)

사용자는 로그인 하기 위해 서버2와 통신한다. 서버1과 서버3은 session id를 가지고 있지 않다. 만약 사용자가 서버1이나 서버3에 요청을 보낼 경우 일치하는 session id가 없기 때문에 상태를 유지할 수 없고 로그인이 풀리게 된다.

이러한 문제를 해결하기 위한 방법은 세 가지가 있다.

- Sticky Session
- Session Clustering
- Session Storage

## Sticky Session

![img3](/assets/images/Sticky%20Session.png)

Sticky Session은 사용자의 세션을 처음 생성한 서버가 해당 사용자의 작업을 담당하여 고정된 세션만 사용한다. 즉 user1이 A 서버에 처음 로그인 요청을 하여 세션을 생성하였다면, 앞으로의 모든 user1의 요청은 A 서버에만 보내지게 된다. 이렇게 특정 사용자의 요청을 하나의 서버로 고정시키기 위해 로드밸런서는 요청을 보낸 사용자의 ip주소나 클라이언트의 요청에 쿠키가 존재하는지 확인 후 작업이 이루어진다. 

결론적으로 Sticky Session방식으로 사용자는 세션이 유지되는 동안 하나의 서버만 사용하게 되므로 세션 불일치 문제가 발생하지 않는다.

**Sticky Session의 단점**

1. **세션 정보를 잃어버릴 수 있다.**

특정 서버에 장애가 발생하면 해당 서버로 요청을 보내는 사용자의 세션 정보를 잃어버릴 수 있기 때문에 해당 서버에 고정된 유저는 다시 로그인해야 하는 문제점이 있다.

2. **특정 서버에 트래픽이 몰릴 수 있다.**

로드밸런서는 여러 서버에 요청을 적절히 분산하여 부하가 특정 서버에 몰리지 않기 위해 사용한다. 하지만 Sticky Session으로 인해 한 서버에 트래픽이 몰리면 로드밸런서의 원래 목적을 달성할 수 없다.

## Session Clustering

![img4](/assets/images/Session%20Clustering.png)

