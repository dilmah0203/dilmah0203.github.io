---
layout: single
title : HashMap은 어떻게 구현되어 있을까?
excerpt : ""
---

HashMap은 key-value 쌍으로 구성되어 있는 자료구조이고 하나의 key는 하나의 value만 가질 수 있다. 그리고 삽입, 삭제, 검색에 평균 O(1)의 시간복잡도를 가진다. 그렇다면 HashMap은
어떻게 구현되어 있길래 키와 값을 빠르게 매핑할 수 있을까?

만약 알파벳을 사용한다면 총 26개의 공간만 필요하기 때문에 큰 문제가 되지 않는다. 하지만 정수를 사용한다면 2,147,483,647의 공간이 필요하고 메모리 낭비로 이어질 수 있다. 

HashMap은 **버킷**(bucket)에 요소를 저장하고 이러한 버킷의 수를 **용량**(capacity)이라고 하는데 값을 넣을 때 hashCode() 메소드를 사용해서 값이 저장될 버킷을 결정한다. 검색에도
hashCode()를 사용하여 버킷을 계산한다. 그리고 해당 버킷에서 찾은 객체들을 순회하여 equals를 통해서 같은지 다른지 여부를 판단한다.

## 해시 충돌

올바르게 동작하려면 동일한 키는 같은 해시 값을 가져야한다. 하지만 다른 키도 같은 해시 값을 가질 수 있다.

만약 다른 키가 같은 해시 값을 가질 경우에 해당 키에 속한 값은 같은 버킷에 채워지게 되는데 어떻게 될까? 이 때는 버킷 내부에서 list 형태로 요소들을 관리한다. 그래서 버킷 내부에서 요소들을 검색
할 때는 반복문으로 돌아야 하기 때문에 O(n)의 시간이 걸리게 된다.

> Java 8에서 버킷에 8개 이상의 값이 포함되면 버킷 내부의 값이 저장된 데이터 구조가 balanced tree로 변경되고 O(log n)로 향상된다.

## HashMap의 내부 동작원리

![img](/assets/images/HashMap1.png)

**초기 용량(initialCapacity)**

버킷의 초기 용량으로 기본 용량은 16이다. 버킷의 75%가 차면 용량을 2배로 늘리는 과정이 일어난다. 

**로드 팩터(load factor)**

로드팩터는 데이터의 개수/초기 용량 값으로 용량을 언제 재설정 해주어야 효율적인지를 나타낸다. 초기 값은 0.75로 75%가 채워지면 원래 버킷의 값들을 새로운 버킷에 옮기는 과정이 일어난다.

- 초기 용량을 작게 설정하면 공간 비용은 절감되지만 재할당 빈도가 증가한다.
- 초기 용량을 높게 설정하면 재할당은 줄어들지만 메모리 낭비를 할 수 있다.

<br>

참고

[https://www.baeldung.com/java-hashmap](https://www.baeldung.com/java-hashmap)
