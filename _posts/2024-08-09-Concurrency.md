---
layout: single
title: "동시성 문제를 해결하는 방법들에는 어떤 것이 있을까?"
excerpt: ""
---

- 현재 진행 중인 배달 서비스 프로젝트는 라이더가 주문을 수락하는 과정에서 동시성 문제가 발생할 가능성이 있습니다.
- 여러 라이더가 동시에 동일한 주문을 수락할 경우, 하나의 주문이 여러 라이더에게 할당될 수 있는 상황을 방지하기 위해 다양한 동시성 제어 방법에 대해 알아보게 되었습니다.

## 자바의 synchrozied 키워드

자바에서 제공하는 `synchronized` 키워드를 사용하여 특정 메소드나 코드 블록에 락을 걸어 여러 스레드가 동시에 접근하지 못하게 합니다. `synchronized`를 통해 간단하게 문제를 해결할 수 있으나 하나의 프로세스 내에서만 동시성 제어가 가능하다는 한계가 있습니다. Scale-Out을 통해 서버가 2대 이상일 경우 여전히 동시성 문제가 발생하기 때문에 DB 레벨에서의 동시성 제어가 필요합니다.

## 낙관적 락 vs 비관적 락

### 낙관적 락

- 데이터를 읽을 때 별도의 락을 걸지 않고 애플리케이션에서 제공하는 버전 관리 기능을 사용합니다.
  - 주로 version 등의 구분 컬럼을 사용
- 트랜잭션을 커밋하는 시점에 데이터 충돌 여부를 확인합니다.
  - 만약 두 개의 트랜잭션이 같은 데이터를 수정하려고 할 때, 버전 번호를 비교하여 충돌이 발생한 경우 해당 트랜잭션은 실패하고 롤백됩니다.   
- 락을 걸지 않기 때문에 동시성 처리에서 성능에 유리할 수 있습니다.
  - 업데이트 과정에서만 락을 점유하여 락 점유 시간을 최소화함으로써 동시성을 보장합니다.
- 하지만 수정에 대한 동시 요청이 많을 경우, 일치하지 않는 버전으로 인해 데이터 연산을 정상적으로 반영할 수 없습니다.

### 비관적 락

- 데이터를 읽는 시점에서 락을 획득하고, 연산이 끝날 때까지 락을 유지합니다.
  - 트랜잭션이 시작될 때 X-Lock 혹은 S-Lock을 설정하여 다른 트랜잭션이 동일한 데이터를 수정하거나 읽지 못하도록 합니다.
- 데이터 수정 과정에서 즉시 트랜잭션 충돌을 알 수 있습니다.
  - 락을 획득하지 못하면 다른 트랜잭션은 대기 상태에 들어가거나, 충돌이 발생해 실패하게 됩니다. 
- 안전성은 높지만 성능 저하 가능성이 있습니다.
  - 충돌을 방지할 수 있지만 여러 트랜잭션이 대기 상태로 들어가거나 교착 상태 문제가 발생할 수 있습니다.

## 분산 락

- 서버가 여러 대인 경우 동일한 데이터에 대해 동기화를 보장하기 위해 사용합니다.
- 서버들 간 동기화 처리가 필요하고, 공통된 락을 적용해야 하기 때문에 redis를 이용해 분산락을 사용합니다.
- 공통된 데이터 저장소(DB)를 이용해 자원이 사용중인지 확인하기 때문에 전체 서버의 동기화된 처리를 보장합니다.

### Redis 기반 분산락 사용하기

Lettuce와 Redisson과 같은 Redis 클라이언트를 사용하여 분산 락을 구현할 수 있습니다.

- Lettuce
  - 기본적으로 스핀락을 사용하여 분산 락을 구현합니다. 
  - 스핀락 방식은 락을 획득하기 위해 계속해서 시도하는 방식으로, 락을 기다리는 동안 CPU 자원을 사용하게 됩니다.
 
아래와 같이 사용할 수 있습니다.

```java
void doProcess() {
    String lockKey = "lock";

    try {
        while (!tryLock(lockKey)) { // (2)
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        
        // (3) do process
    } finally {
        unlock(lockKey); // (4)
    }
}

boolean tryLock(String key) {
    return command.setnx(key, "1"); // (1)
}

void unlock(String key) {
    command.del(key);
}
```

(1) tryLock 메소드는 Redis의 `SETNX` 명령어를 사용하여 락을 시도합니다. `SETNX`는 'SET if Not Exists'의 약자로, Redis에서 키가 존재하지 않을 경우에만 값을 설정합니다. 만약 키가 이미 존재하면 락을 획득하지 못한 것으로 간주하여 실패를 반환합니다.
(2) tryLock이 false를 반환하면, 즉 락을 획득하지 못하면, Thread.sleep(50)을 통해 일정 시간 대기합니다. 이후 다시 tryLock을 호출하여 락을 획득할 수 있을 때까지 반복합니다. 이 과정은 '스핀락'이라고 불립니다.
(3) 락을 성공적으로 획득한 후에는 프로세스를 수행합니다. 
(4) 프로세스가 끝난 후에는 unlock 메소드를 호출하여 Redis에서 락을 해제합니다. unlock 메소드는 Redis에서 키를 삭제하여 락을 해제합니다. 

하지만 해당 방식엔 다음과 같은 문제점이 있습니다.

락을 획득하지 못한 경우 무한루프를 돌게 됩니다. 그렇기 때문에 일정 시간이 지나면 만료되도록 해줘야 하는데 `SETNX` 명령어에 expire time을 설정할 수 없습니다. 또한 지속적으르 락의 확득을 시도하기 때문에 많은 부하가 발생할 수 있습니다.

- Redission
  - 스핀락 방식이 아닌 pub/sub 기능을 이용하여 락을 관리합니다. 

```java
```

## 정리

만약 여러 서버가 하나의 DB를 공유하고 있는 경우 낙관적 락이나 비관적 락을 통해 충분히 동시성 문제를 해결할 수 있다. 하지만 분산 DB 환경에서는 낙관적 락이나 비관적 락으로는 동시성 문제를 완전히 해결하기 어렵기 때문에 분산 락을 사용해야 한다.
