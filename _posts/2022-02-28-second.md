---
layout: single
title : "**추상클래스 vs 인터페이스(+자바8에서의 변경점)**"
excerpt : ""
---

<br>

- **추상클래스**
  - 0개 이상의 추상메소드를 가짐
  - 구체적인 로직을 가지고 있지 않고, 로직을 위한 시그니처(형식)만을 가지고 있음
  - 추상메소드를 하나라도 가지고 있으면 반드시 클래스는 abstract로 선언되어야 함
  - **abstract로 선언한 메소드**를 자식 클래스에서 반드시 구현해야 한다(오버라이딩)
  - 추상클래스 내에는 추상메소드가 아닌 메소드가 존재 할 수 있으며, static이나 final 메소드가 있어도 된다

<br>

> **사용이유** <br>
>
> 상속을 강제하기 위한 것이다. <br>
>
> 즉, 부모 클래스에는 메소드의 형식만을 정의해놓고 실제 동작은 이 메소드를 상속받은 하위 클래스의 책임으로 위임한다.

<br>

```java
public abstract class AbstractTest { // 추상클래스
    String data;
    public abstract void addMember(String name); // 추상메소드(로직을 가질 수 없다)
    public abstract int a();

    public void printLog(String data) { // 일반메소드(로직을 가지고 있음)
	this.data = data;
    }
}
```

```java
public class C extends AbstractTest {
    public void addMember(String name) { //추상메소드 구현
	System.out.println("addMember : "+name);
    }
    public int a() {
	return 1;
    }
}
```

```java
public class AbstractDemo {
    public static void main(String[] args) {
	AbstractTest test = new C();
	test.addMember("Lee");
        System.out.println(test.a());
    }
}
```

```java
> addMember : Lee
> 1
```

<br>

- **인터페이스**
  - abstract, final과 함께 대표적인 규제
  - 어떤 객체가 특정한 인터페이스를 사용한다면 그 객체는 반드시 인터페이스의 **모든 메소드**들을 구현해야 함
  - 인터페이스에 정의되는 멤버들의 접근제어자는 public이어야 한다
  - 추상클래스와 달리 일반메소드, 멤버 변수를 가질 수 없다
  - 모든 멤버 변수는 **public static final**이어햐 하며, 이를 생략할 수 있다
  - 다중 상속이 가능하다
  
<br>

   public static final의 사용 목적? <br>
   인터페이스 변수는 인스턴스가 존재하지 않는 시점이기 떄문에 스스로 초기화 될 수 없다. <br>
   그렇기 때문에 public static final를 사용해 구현 객체의 같은 상태를 보장한다.

<br>

> **사용이유** <br>
>
> 여러명이 협업하여 프로젝트 진행 시 서로가 만들고 있는 기능들은 상관관계를 만들어낸다. 이러한 경우, 개발자는 다른 개발자의 클래스가 완성이 되어야 개발이 가능한 경우가 생긴다. 이 때 더미 클래스라는 가짜 클래스를 만들어 채워 넣은 뒤 클래스가 완성한 후에 바꿔줌으로서 일정에 차질이 생기지 않게 된다. <br>
>
> 두 개발자는 같은 인터페이스를 사용하고 있고, 인터페이스의 메소드는 형식만 갖추어져 있다. <br>
>
> 인터페이스로 메소드의 형식을 잡아놓지 않는다면 많은 양을 리팩터링 해야하는 경우가 발생할 수 있다.

<br>

```java
public interface Calculatable {
    public void set(int a, int b);
    public int sum();
    public int avg();
}
```

```java
public class Calculator implements Calculatable {
    int a,b;
    public void set(int a, int b) {
	this.a = a;
	this.b = b;
    }
    public int sum() {
	return this.a + this.b;
    }
    public int avg() {
	return (this.a + this.b)/2;
    }
}

```

```java
public class CalculatorMain {
    public static void main(String[] args) {
	Calculatable c = new Calculator();
	c.set(2, 4);
	System.out.println(c.sum());
	System.out.println(c.avg());
    }
}
```

```java
> 6
> 3
```
<br>

- **공통점** 

  추상클래스와 인터페이스 둘 다 가지고 있는 추상 메소드를 구현하도록 강제한다. 
  
  또한 인스턴스화가 불가능하다.

<br>

> 추상클래스 안의 메소드를 전부 추상메소드로 만들면 인터페이스 역할을 할 수 있다. <br>
> 
> 만약 모든 클래스가 인터페이스만을 사용해서 구현한다면, 공통으로 필요한 기능들을 오버라이딩 하게 되기 때문에 코드의 중복이 발생한다.
> 
> 그렇다면 인터페이스는 왜 필요할까?



<br>

- **접근 제어자** (Java 8 기준) <br>

  인터페이스에서 모든 변수는 기본적으로 public static final, 모든 메소드는 public abstract인 반면 추상 클래스는 static이나 final이 아닌 필드를 지정할 수 있고 public, protected, private 메   소드를 가질 수 있다. 

  인터페이스만을 구현하면 public static final만을 사용하여 객체의 같은 상태를 공유할 수 밖에 없는데, 추상 클래스는 static이나 final이 아닌 필드또한 가질 수 있기 때문에 추상클래스를 상속 받은 객체들이 같은 상태를 가지고 있을 수 있다.
  
 <br>
  
- **다중 상속**
  
  인터페이스를 구현하는 클래스는 여러개의 인터페이스를 구현할 수 있지만, 추상 클래스는 다중 상속이 불가능하다. 
  
  다중 상속 여부에 따라 추상클래스와 인터페이스의 사용 의도가 다르다.
  
 <br>
 
- **정리**

  **추상클래스**는 상속할 객체들의 공통점을 추상화 시킨 것으로, 부모 클래스가 가진 기능들을 구현해야 할 경우에 사용한다. 
  관련성이 높은 클래스 간의 코드 공유가 필요한 경우, public 이외의 접근자(protected, private) 선언이 필요한 경우, non-static과 non-final 필드 선언이 필요한 경우 적절하다.
  
  **인터페이스**는 다른 조상 클래스를 상속하더라도, 같은 기능이 필요할 경우 사용한다. 
  클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장한다. 
  
 <br>
  
 - **자바8에서의 변경점**

    자바 인터페이스의 변경점은 **두 가지**가 있다. <br>
    기존(자바 7이전)에는 추상 메소드 선언 및 상수 정의만 가능했다.

    1. Default Method
    2. Static Method

  <br>
  


- **Default Method**

```java
public interface Calculator {

    public int plus(int i, int j);
    public int minus(int i, int j);

    default int multiple(int i, int j){
        return i * j;
    }
}
```

```java
public class CalculatorMain implements Calculator{
    @Override
    public int plus(int i, int j) {
        return i+j;
    }

    @Override
    public int minus(int i, int j) {
        return i-j;
    }

    public static void main(String[] args) {
        Calculator calculator = new CalculatorMain();
        int multipleValue = calculator.multiple(3, 20);
        System.out.println("multipleValue = " + multipleValue);
    }
}
```

```java
> multipleValue = 60
```

<br>

- **Static Method**

  static method는 override가 불가능하다. <br>

  또한, public static final 상수를 선언할 때는 선언과 동시에 초기화 해야한다.

```java
public interface StaticCalculator {
    public int plus(int i, int j);
    public int minus(int i, int j);

    public static int multiple(int i, int j){
        return i * j;
    }
}
```

```java
public class CalculatorMain implements Calculator{
    @Override
    public int plus(int i, int j) {
        return i+j;
    }

    @Override
    public int minus(int i, int j) {
        return i-j;
    }

    public static void main(String[] args) {
        Calculator calculator = new CalculatorMain();
        int staticMultipleValue = StaticCalculator.multiple(10, 20);
        System.out.println("staticMultipleValue = " + staticMultipleValue);
    }
}
```

```java
> staticMultipleValue = 300
```



