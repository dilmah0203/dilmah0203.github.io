---
layout: single
title : "추상클래스 vs 인터페이스"
excerpt : ""
---

# 💡 **추상클래스 vs 인터페이스**

<br>

- **공통점** 

  추상클래스와 인터페이스 둘 다 가지고 있는 추상 메소드를 구현하도록 강제한다. 
  
  또한 인스턴스화가 불가능하다.

<br>

> 추상클래스 안의 메소드를 전부 추상메소드로 만들면 인터페이스 역할을 할 수 있다. <br>
> 
> 만약 모든 클래스가 인터페이스만을 사용해서 구현한다면, 공통으로 필요한 기능들을 오버라이딩 하게 되기 때문에 코드의 중복이 발생한다.
> 
> 그렇다면 공통으로 필요한 기능들을 부모클래스에서 일반메소드로 구현한 추상클래스를 상속받아 자식 클래스에서 사용할 수 있지 않을까?
> 

<br>

- **접근 제어자** (Java 8 기준) <br>

  인터페이스에서 모든 변수는 기본적으로 public static final, 모든 메소드는 public abstract인 반면 추상 클래스는 static이나 final이 아닌 필드를 지정할 수 있고 public, protected, private 메   소드를 가질 수 있다. 

  인터페이스만을 구현하면 public static final만을 사용하여 객체의 같은 상태를 공유할 수 밖에 없는데, 추상 클래스는 static이나 final이 아닌 필드또한 가질 수 있기 때문에 추상클래스를 상속 받은 객체들이 같은 상태를 가지고 있을 수 있다.
  
 <br>
  
- **다중 상속**
  
  인터페이스를 구현하는 클래스는 여러개의 인터페이스를 구현할 수 있지만, 추상 클래스는 다중 상속이 불가능하다. 
  
  다중 상속 여부에 따라 추상클래스와 인터페이스의 사용 의도가 다르다.
  
 <br>
 
- **정리**

  **추상클래스**는 상속할 객체들의 공통점을 추상화 시킨 것으로, 부모 클래스가 가진 기능들을 구현해야 할 경우에 사용한다. 
  
  관련성이 높은 클래스 간의 코드 공유가 필요한 경우, public 이외의 접근자(protected, private) 선언이 필요한 경우, non-static과 non-final 필드 선언이 필요한 경우 적절하다.
  
  **인터페이스**는 다른 조상 클래스를 상속하더라도, 같은 기능이 필요할 경우 사용한다. 
  
  클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장한다. 


