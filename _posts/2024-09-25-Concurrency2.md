---
layout: single
title: "분산락을 사용하여 동시성 문제 해결하기"
excerpt: ""
---

제가 지금 진행중인 프로젝트는 동시성 문제를 가지고 있었습니다.

- 두 명의 배달 기사가 동시에 배달 요청된 주문을 수락합니다.
- 주문 상태가 DELIVERY_REQUESTED인 상태에서 두 배달 기사가 동시에 접근하면, 중복 배차 문제가 발생할 수 있습니다.

![img](/assets/images/Concurrent.png)

## 문제 해결 방법

- **낙관적 락**
    - 버전 정보를 이용하여 데이터를 읽을 때는 락을 걸지 않고, 데이터를 업데이트할 때만 충돌을 감지하는 방식입니다. 동시에 접근하는 트랜잭션이 많을 때 성능에 좋지 않을 수 있습니다.
- **비관적 락**
    - 데이터를 읽을 때부터 해당 데이터에 대한 락을 걸어 다른 트랜잭션이 해당 데이터를 변경할 수 없게 합니다. 하지만 이는 성능 저하를 유발할 수 있으며, 락이 해제될 때까지 다른 트랜잭션은 대기해야 합니다.
 
라이더가 동시에 하나 이상의 배달을 받을 수 없게 보장하기 위해, 또 데이터의 정합성을 고려한다면 비관적 락을 사용하는 것이 낫겠다고 생각하였습니다.

현재 프로젝트는 외부 API 호출 시에 서버 비용 절감과 읽기 성능 향상을 위해 캐시를 사용하고 있습니다. 지금은 단일 서버 환경이지만 확장 가능성을 고려했을 때 분산 서버 환경에서 서버간 데이터 일관성 유지를 위해 redis를 캐시 저장소로 활용하고 있습니다. 단일 서버 환경에서는 비관적 락만으로도 동시성 문제를 해결할 수 있지만 분산 시스템의 경우 분산 락을 사용할 수 있다고 보았고 redis를 이용하여 분산 락을 구현하기로 하였습니다.

- **분산 락**
    - 저희가 선택한 방식은 Redis를 이용한 분산 락입니다. Lettuce로 분산 락을 사용하기 위해서는 `setnx`, `setex` 등을 이용해 분산 락을 직접 구현해야 합니다. 개발자가 직접 retry, timeout과 같은 기능을 구현해주어야 하는 번거로움이 있습니다. 이에 비해 Redission은 별도의 Lock interface를 지원합니다.
    - Lettuce는 분산락 구현 시 `setnx`, `setex`과 같은 명령어를 이용해 지속적으로 Redis에게 락이 해제되었는지 요청을 보내는 스핀락 방식으로 동작하기 때문에 요청이 많을수록 redis의 부하는 커지게 됩니다.
    - 이에 비해 `Redisson`은 Pub/Sub 방식을 이용하여 락이 해제되면 락을 기다리던 쓰레드들은 락이 해제되었다는 신호를 받고 락 획득을 시도합니다.
